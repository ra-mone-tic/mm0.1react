Role: You are a senior full-stack developer (Python, JavaScript, SQL) with expertise in GIS, cartography, and data engineering.

Ultimate goal: Build a lightweight yet functional web service for displaying an interactive map, managing markers, and performing geocoding (address↔coordinates) with minimal reliance on paid external APIs — adapted specifically for MeowMap in Kaliningrad (Russia).

Localization requirement: The service UI (all labels, controls, messages, and default content) must be in Russian.

Technical context:

1. Stack: Backend — Python (FastAPI or Flask). Frontend — Vanilla JS or a lightweight framework (Leaflet.js for maps). Data — SQLite initially, with a clean migration path to PostGIS.


2. Map data: Use free map tiles from open sources (e.g., OpenStreetMap). For production, plan for hosting or caching tiles to respect public tile usage policies.


3. Geocoding: Prefer offline/near-offline operation using pre-downloaded and processed local datasets for Kaliningrad and the Kaliningrad Oblast. Source examples: OpenStreetMap extracts (.osm.pbf) filtered to relevant features (place=, highway=, addr:*), and optionally preprocessed CSV/GeoJSON. Include Russian names (name:ru) wherever possible.


4. Principle: Code must be modular, well-commented, and educational. Each logical part should explain what it does, why it exists, and how it works.




---

Step-by-step execution plan (Prompt Chain):

Step 1: Architecture design and base environment

• Task: Design project structure and spin up a base server.
• Action:
– Create folders: /backend, /frontend, /data, /utils.
– Initialize a simple HTTP server with FastAPI/Flask.
– Implement base endpoints:
GET / → serves the HTML page (map UI, in Russian),
GET /health → API status check.
– Comment on framework selection and project structure decisions.
• Code requirement: Single-command run (e.g., python app.py or uvicorn main:app --reload).

Step 2: Map module (Tile Server client)

• Task: Render a base map on the frontend.
• Action:

1. Create an HTML page with a container <div id="map"></div>.


2. Load Leaflet.js via CDN.


3. Initialize the map centered on Kaliningrad: [54.7104, 20.4522], reasonable zoom (e.g., 12).


4. Add a tile layer using a public OSM server: https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png.
• Code requirement: Keep the frontend minimal and independent. Comment how the tile system works (z/x/y), note public tile usage limits/rate-limits, and outline a future tile caching/self-hosting plan.



Step 3: Marker module

• Task: Implement adding, storing, and displaying user markers on the map.
• Action:
Backend:
– Create a SQLite model/table for markers: (id, latitude, longitude, title, description, created_at).
– Endpoints:
GET /api/markers → return all markers as JSON.
POST /api/markers → accept JSON { lat, lng, title, description? }, insert into DB.
DELETE /api/markers/{id} → delete marker by id.
Frontend:
– Load markers from /api/markers and render with L.marker.
– Add a map.on('click', ...) handler that POSTs to /api/markers to create a new marker and renders it immediately.
– Show a simple popup or form (in Russian) to input title (and optional description) when creating a marker.
• Code requirement: Put DB logic into a separate module (e.g., database.py). Comment SQL and the schema. All UI strings are Russian.

Step 4: Reverse geocoding module

• Task: On map click/marker creation, display not only coordinates but also an approximate address/place name in Russian.
• Action:

1. Data prep (Kaliningrad focus): Provide a script /utils/load_geodata.py that ingests a preprocessed dataset into SQLite. Prefer OSM extract for Kaliningrad Oblast (.osm.pbf → filtered to places/streets/POIs and exported to CSV/GeoJSON with Russian names). As a lightweight fallback, allow GeoNames RU-focused CSV (e.g., cities/towns), acknowledging coarser granularity.


2. Backend: Implement GET /api/reverse_geocode?lat=...&lng=....


3. Algorithm: Given (lat, lng), find the nearest relevant feature within ~50 km. Use Haversine distance or a bounding-box prefilter + distance sort.
Example SQL:
SELECT name_ru, feature_type, country_code, (...) AS distance   FROM places   WHERE latitude BETWEEN ? AND ? AND longitude BETWEEN ? AND ?   ORDER BY distance ASC LIMIT 1;
(Ensure name_ru/name fields support Cyrillic; fall back to name if name_ru is missing.)


4. Frontend: After creating a marker, call /api/reverse_geocode and update the marker popup with the Russian place name plus coordinates.
• Code requirement: This module is the core of “independence.” Thoroughly comment the search logic, accuracy, and limitations. Document data sources and preparation steps, including Russian naming.



Step 5: Forward geocoding module

• Task: Add a “Google-Maps-like” search bar: user types a place name (in Russian), the map centers on the result.
• Action:

1. Backend: Implement GET /api/geocode?q=....


2. Algorithm: Query the places table for matches on Russian names (name_ru) using LIKE or SQLite FTS5 if available. Return JSON array of candidates with coordinates. Consider simple ranking (prefix match > substring, shorter distance to current map center, etc.).


3. Frontend: Add <input type="text" id="search" placeholder="Поиск по карте"> and a button. On click, call /api/geocode, render suggestions (autocomplete in Russian), and on selection, set map view + drop/flash a marker.
• Code requirement: Comment search limitations (case, Cyrillic specifics, need for exact forms). Suggest future improvements (stemming, synonyms, typo tolerance; migration to PostGIS + Elasticsearch later).




---

Final deliverable requirements:

1. Fully working prototype: Provide ready-to-run files.


2. Comments: Every significant block (functions, non-trivial logic, SQL) explains WHAT/WHY/HOW.


3. Modularity: Split code into logical files/modules (e.g., app.py, database.py, geocoder.py, index.html, /utils scripts).


4. Educational README.md: Explain architecture and trade-offs, current limitations (geocoding precision for Russian addresses, performance with larger datasets), and scaling paths (PostGIS migration, Elasticsearch for search, tile caching/self-hosted tiles, spatial indexes, bounding-box indices).


5. Kaliningrad defaults & Russian UI: Default map view is Kaliningrad, Russia; all UI strings, examples, and data handling prioritize Russian language content.



